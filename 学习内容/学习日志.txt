
====================================================================

数据结构_链表
	1.查询慢
	2.增删快
	链表中的每一个元素也称为一个节点
	一个节点包含了一个数据源（存储数组），两个指针域（存储地址）
		【自己的地址】【数据】【下一个节点的地址】
单向链表：链表中只有一条链子，不能保证顺序
双向链表：链表中只有二条链子，保证顺序

二叉树：分支不能超过两个
【排序树/查找树】
在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大

【平衡树】：左孩子和右孩子相等
【不平衡树】
【红黑树】：趋近于平衡树，查询速度非常的快，查询叶子节点最大次数和最小次数不能超过2倍

约束：
1.节点可以是红色的或者是黑色的
2.根节点是黑色的
3.叶子节点（空节点）是黑色的
4.每个红色的节点的子节点都是黑色的
5.任何一个节点到其每一个叶子节点的所有路径上黑色节点相同

前序：根左右
中序：左根右
后续：左右根
把一个子树作为一个整体

查找算法：
暴力：遍历
二分：前提条件:有序  B+树的基础算法
哈希：最高效o(1)  jdk 1.8链表加红黑树（处理hash冲突）
哈希冲突的产生原因
哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的哈希值。这时候就产生了哈希冲突。
插值：
索引：搜索索引
bfs&dfs：
平衡树：
B+树：
B-Tree：
红黑树：高效的查找：
底层数据结构：特殊的查找树（自平衡的二叉查找树）
1.每个节点不是红色就是黑色
2.不可能有连在一起的”红色“节点
3.根节点都是黑色
4.每个红色结点的两个子节点都是黑色，叶子节点都是黑色；
出度为0满足了性质就可以近似的平衡，不一定要红黑，可以为其他的

变化规则
1.变颜色（父节点，叔叔节点，祖父节点变色）
当前节点的父亲是红色，且它的祖节点的另一个子节点也是红色（叔叔节点）
2.旋转(左旋，右旋)：
左旋：右子树 父节点是红色，叔叔节点黑色  以父节点作为左旋
右旋：父节点红色，叔叔黑色，右旋
缺点：
1.读取磁盘的次数过多

B树：B-tree,B+Tree  balance tree 
B树 N叉的排序树
1.节点最多含有m颗子树（指针）m-1个关键字（数据）
2.除根节点和叶子节点外，其他每个节点至少有ceil(m/2)个子节点
3.若根节点不是叶子节点，则至少有两颗子树
4.ceil为取数 当数据=时分裂从中间分开，分成两颗子树
n》= ceil(m/2) 


B+树（双向链表）  有利于范围查询
1.叶子节点连起来了
2.非叶子节点不存数据
3.数据和节点一样多

mysql索引最左原则

===============================================
maven学习
1.maven是一款服务于java平台的自动化构建工具
	maven->gradle
2.构建
	1.概念：生成一个可以运行的项目的过程
	编译-部署-搭建

4.安装Maven核心程序
	1.检查JAVA_HOME环境变量
5.Maven的核心概念
	1.约定的目录结构
	2.POM
	3.坐标
	4.依赖
	5.仓库
	6.生命周期
	7.继承
	8.聚合
pom maven核心配置文件
	
maven命令
注意：执行与构建相关的Maven命令，必须进入pom文件所在的目录
	与构建过程相关：编译，测试，打包
常用命令
	mvn clean:清理
	mvn compile 编译主程序
	mvn test-compile:编译测试程序
	mvn rest:执行测试
	mvn package: 打包
	mvn install 命令可以让项目进行仓库
关于联网问题：
	Maven的核心程序中仅仅定义了生命周期，但是具体的工作必须由特定的插件来完成，而插件本身并不包含再maven的核心程序中
	当我们执行的mavne命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找
	本地仓库的默认位置：【系统中当前用户的家目录】\.m2\repository
	maven如果找不到，就会去仓库下载

pom :Project Object Model 项目对象模型

pom.xml对于maven工程是核心配置文件，与构建相关的的一切设置都在这个文件中进行配置
	
坐标
	使用下面三个向量在仓库中唯一定位一个maven工程
	groupid:公司或者组织域名倒叙+项目名
	<groupid></groupid>
	artifactid:模块名
	<artifactd>Hello</artifactd>
	version:版本
	<version>1.0.0</version>
11.仓库
	仓库的分类：
		1.本地仓库
		2.远程仓库：私服:nexus
			中央仓库:
			镜像仓库:
仓库中保存的内容：Maven工程
		1.maven自身所需要的插件
		2.第三方框架或工具的jar包
		3.我们自己开发的Maven工程

	<version>
	release 分离 正式版已经开发完善
	snapshot 快照 不稳定版本
12.依赖
	1.Maven解析mavne依赖信息时会到本地仓库中找包
	 mvn install 命令可以让项目进行仓库
	2.依赖的范围<scope>
		1.compile
			对主程序有效
			对测试程序有效
			参与打包
		2.test
			不参与打包
			对主程序、对测试程序无效
			
		3.provided
			
			仅开发时依赖
			
		4.deploy
		//配置当前工程构建过程中的特殊设置
		<build>
			//
			<plugins>
				<plugin>
					//配置当前系统中容器的位置
					<container>
						
					</container>
				</plugin>
			</plugins>
			
			//配置插件在什么情况下执行
			<executions>
				//生命周期的节点
				<phase></phase>
				<goals>
					<goal></goal>
				</goals>
			</executions>
		</build>

依赖的传递性
	好处：可以传递的依赖不必在每个模块中工程中都重复说明
		非compile的依赖不能传递
依赖的排除
		<exclusion>
			<groupid></groupid>
			<artifactd></artifacted>
		</exclusion>
	作用：解决模块间的jar包冲突
	
	情景：验证路径依赖最短优先政策
	情景：验证路径相同时先声明者优先	代码从上到下执行！
	
	自定义标签
	声明：<property>
		<version>4.0.0</version>
	</property>
	
	引用：${version}
	
继承
	统一管理各个模块工程中对junit依赖的版本
	将依赖统一提取到“父”工程中，在子工程中声明依赖
	操作：
		1.创建一个MAVNE工程作为父工程。注意：打包的方式 pom（不是jar或者war）
		2.在子工程中声明父工程的依赖
		<parent>
			//以当前文件为基准的父工程pom.xml的相对路径
			<relativePath>../parent/pom.xml</relativePath>
		</parent>
		
		子工程中将依赖版本删除
		
		父工程中 	配置父子中统一依赖
		<dependencyManager>
			<dependencies>
			
			</dependencies>
		</dependencyManager>
		3.将子工程中的坐标中与父工程坐标重复的内容删除
		4.在父工程中统一junit的依赖
		5.在子工程中删除junit的依赖的版本号
		6.配置继承后，需要将父工程先install
聚合	
		作用：一键安装各个模块工程
		<modules>
			<!--指定子模块-->
			<module></module>
		</modules>
====================================================		
git学习
本地库  历史版本
	git commit
暂存区  存代码
	git add
工作区  写代码

fork

pull request->审核 ->merge


用户设置
git config user.name
git config user.email项目级别/仓库级别

git config --global 系统用户级别
就近原则：项目级别优先于系统用户级别，二者都有时采用项目界别的签名

vim set nu设置行号

================================================
zookeeper：基于观察者模式设计的分布式服务管理框架
文件系统+通知机制
每一个znode默认存储一个1m的数据
每个znode可以通过唯一标识符找到
（序列化的特性）
路径必须是通过绝对路径访问

znode:
	1.stat:状态信息
	2.data:与znode关联的数据
	3.children：改znode下的子节点
临时节点：
永久节点：

1.统一命名服务
2.统一配置管理
3.统一集群管理
4.服务器动态上下线
5.软负载均衡

全局数据一致
可靠性
顺序性：有序和偏序
数据更新原子性：要么成功要么失败
实时性

leader
事务请求的唯一调度和处理者

flower
处理客户端非事务请求，转发事务请求给leader,参与投票leader

此外针对访问量较大的zookeeper集群还可以新增观察者角色
observer:
不参与投票，仅作为 观察同步最近状态，非事务处理请求转发

2n+1台server组成
集群数量一般为奇数
emphemeraOwner：临时节点
create [-s][e] path data acl 创建节点
set path data 设置节点数据
delete path  删除节点  如果存在子节点，那么无法删除，必须删除子节点

==================quota 

setquota 对节点进行设置
setquota  -n 3 /hellozk
listquota  列出值节点的quota
delquota  删除quota

history 查看历史命令

zookeeper watcher
分布式数据 发布/订阅功能

==============watch机制特定
监听是一次性的，只能展示一次监听信息
get path watch  设置节点数据变动监听


=====================
=====================选举机制
fastLeaderElection:投票大于半数则胜出
全新集群：
1.每个机器都给自己投票
2.投票过半选举结束
非全新集群：
机器down掉，重新选举
选举三个属性：数据Id：数据更新机器的version就会增加（数据每次更新version增加）
			服务器ID：myid的值，每个机器一个
			逻辑时钟：每次选举过程中，从0递增，down掉的机器不增加
选举标准：
	1.逻辑时钟小的选举结果被忽略，重新投票
	2.统一逻辑时钟后，数据id大的胜出
	3.数据id相同的时候，服务器id大的胜出，根据这个规则选出leader
==================数据发布与订阅（配置中心）
1.统一管理的数据不能太大

过程：
1.所有订阅者初次启动时候去zk指定的节点获取相关的订阅信息
2.获取数据的同时，还有设置监听，监听节点数据的变化
3.一旦节点数据发生改变，监听就会被出发，我们各个应用（订阅者，相当于zk）
就是客户端，就会收到事件的通知，从而获取新的配置信息）
4.重新配置监听
=======================
命名服务：
在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取
资源或服务的地址，提供者等信息。
被命名的实体通常是集群中的机器，提供的服务地址，远程对象等等（名字）
根据zk创建唯一path
===========================
分布式锁

保持独占
1。要求所以的应用首先先去zk上指定的目录创建节点/aa
节点要求：临时节点，非序列化
2.谁创建成功就获得访问数据文件的权限
3.操作完成，断开跟zk的连接
其他应用如果需要操作这个文件的话就去监听这个目录是否存在

控制时序
序列化控制顺序访问

=======================	
NIO/BIO
BIO:程序未准备好，一直等待执行
NIO 非阻塞模式 （判断是否准备好）
buffer:缓冲区
channel：通道  双向通道
selector：多路复用器，选择器,轮询channel

========================
策略模式
分别封装行为接口，实现算法族，超类里放行为接口对象
在子类里具体设定行为对象。原则就是：分离变化部分
，封装接口，基于接口编程各种功能。此模式让行为的
变化独立于算法的使用者



========================
Java基础到项目实战学习路线整理

Java基础
av80585971

数据库
Mysql：av68811608
Oracle：av81386804
JDBC：av68736927
C3P0：av73840600

前端技术
HTML、CSS、Javascript：av73840600
jQuery：av37976701
Ajax：av15657082 av15866060
Vue：av76249419
微信小程序：av40455083

动态网页
av73840600

编程强化
JVM优化：av70549061
数据结构算法：av83826038 av78639604

软件项目管理
Maven： av52364221
SVN：av73840600 av7959491
Git：av75718460
Jenkins：av83089670

热门技术框架
SSM：av7770852
Mybatis-Plus ：av69233006
Spring Data：av71980390
Spring：av70828462

分布式架构
Dubbo、Zookeeper：av74933720
SpringCloud：av77085442 av89898642
Eureka：av74127911
Skywalking：av80349807

服务器中间件
RocketMQ：av66702383
Kafka：av71991051
Sharding-JDBC：av68736927
Redis：av76235738
MongoDB：av80450883

服务器技术
Tomcat：av67233983
Linux系统：av73840600
CentOS、Virtualbox：av23360560
Ubuntu、Vmware：av14184325

容器技术
Docker：av69121091

业务解决方案（实战项目）
Elasticsearch：av66600360
Lucene：av77895717
Quartz：av36062910
Elastic-Job：av74128695
SpringSecurity：av74851468
Activiti：av7670054

mongdb启动命令  
在所在目录下bin目录打开cmd输入命令启动
mongod --dbpath E:\software\MongoDB\data\db

     账号： username: my_user
      密码：password: password123
db.createUser(
{
user: "my_user",
 pwd: "password123",
roles: [ { role: "dbAdmin", db: "test"} ]
 }
)

dubbo负载均衡
1.基于权重的随机负载均衡机制
2.基于权重的轮询
3.最少活跃数
4.一致性hash
5.基于权重的随机负载均衡机制

服务降级
牺牲非核心业务
1.返回为null
2.超时为null

容错机制
hystrix
