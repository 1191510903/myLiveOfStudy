DBMS_OUTPUT.put_line( 'putline====== ');
plsql 控制台输出数据

mysql 查询优化

内部结构
1.连接层
2.业务服务处理层
3.数据存储引擎层（存储引擎）
4.文件存储层
优点：分层可拔插

常用的引擎：innodb 和 myisam

优化分析：
1)性能下降sql慢
	1.查询语句写的烂
	2.索引失效
		单值
		复合
	select * fron u where name='' and emai='';
	create index  idx_usr on user(name,emai);
	
	查看表索引
	show index from table_name（表名）
	3.关联查询太多join（设计缺陷或不得已的需求）
	4.服务器调优及各个参数设置（缓冲，线程数等）
join查询顺序
	手写：
	机读：from -->on -->where -->group by -->having -->select -->distinct-->order by -->limit
	总结：
	
	from --> on --> join --> where --> group by --> having -->select -->order by 
	
select from a inner join b on a.key =b.key
select from a left join b on a.key = b.key
select from a right join b on a.key = b.key

7种join连接

什么是索引？
	mysql 索引分裂 index 索引是高效得到数据的数据结构
	索引目的在于提高查询效率，可以类比字典
	“排好序的快速查询数据结构”
	
		
	
2)执行时间长
3)等待时间长
1.添加索引
2.


innodb两大类索引
	聚集索引：主键id
	普通索引

①回表查询
select * from table where index_A=''
②索引覆盖 explain 显示using index

explain 显示执行计划包含的信息

select 
	1.id`查询顺序 
		1.id相同，根据id顺序从上到下
		2.id不同，子查询id值越大优先级越高，越先被执行
	derived 衍生虚表
	同级顺序，不同级越大越优先
	2.select_type查询类型{
			1.simple
			2.primary 最外层是子查询语句
			3.subquery 包含子查询
			4.derived 临时表
			5.union union第二个select
			6.union result Union合并查询结果
    3.table 查询的表
	3.type 访问类型
		system》const>eq_ref>ref>range>index>all
		保证查询知多少到range级别，最好在ref
		system 
		const 常量 where id=1
		eq_ref 唯一索引值
	  ！ref 非唯一性索引扫描，查询和扫描的混合体
	  ！range where中出现了between < > 
	  ！index 只遍历了索引树
		all 全表扫描  --这个时候尝试优化
	4.possible_keys 
		是否使用了索引 ：sql存在的索引，索引的东西被列出
	5.key
		最终实际使用了什么索引
			null 没有使用索引
			使用覆盖索引，出现在key中
	6.key_len
		表示索引中使用的字节数，可通过该列计算查询中使用索引的长度
		在不损失精确性的情况下，长度越短越好
		索引字段的最大可能长度，并非实际使用长度
	7.ref 
		显示索引列数使用情况 
	8.rows
		大致估算出所需记录所需要读取的行数
	9.extra 
		包含不合适在其他列中显示但十分重要的额外信息
			using filesort 出现外部排序 需要优化sql
			using temporary 使用临时表   需要立刻优化sql
			using index  使用了覆盖索引，效率很高 
			如果出现using where ，表明索引用来读取数据而非执行查询动作
			using where
			using join buffer  使用连接缓存
			impossble where 
			select table optimized away
			distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值
	索引的建立优化
			索引优化
				范围的参数不能做索引，否则失效，引起filesort
				两个表
				左右连接索引相反加
				三个表
				连接表加索引
	（永远用写结果集驱动大结果集）
	（优化内层循环）
	（保证Join后面条件加索引）			
索引失效
	1)最佳左前缀法则：
	如果索引了很多列 ，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列
	2)不在索引上做任何操作（计算函数（自动or手动）类型转换），会导致索引失效而转向全表扫描
	
	1.全值匹配我最爱    
	2.带头大哥不能死，中间兄弟不能断
	3.索引列上少计算 
	4.范围之后全失效  > < in like betweent
	5.尽量使用覆盖索引（只访问索引的查询（索引列和查询一致））减少select *
	6.使用！= 或 <> 无法使用索引会导致全表扫描
	7.is null 和 is not null 不能使用索引
	8.like 索引失效（%加右边索引才不会失效，后面也会生效），后面的条件也会失效
		使用覆盖索引可以使索引生效
	9.对于连续的数值，能用 between就不要用 in
	10.字符串varchar一定要加''
	11.少用or
	
	小总结
		：sql内部优化
		order by 会导致索引失败，全局排序，除非参数是一个定值在where中的条件
		group by 分组之前必排序
			会有临时表
	一般建议：
		对于单值索引，尽量选择针对当前query过滤性更好的索引
		在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
		在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引
		尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
		
		
		口诀
			全职匹配我最爱，最左前缀要遵守
			带头大哥不能死，中间兄弟不能断
			索引列上少计算，范围之后全失效
			like百分写最右，覆盖索引不写星
			不等空值还有or，索引失效要少用
	mysql底层会对符合的数据进行类型转换成符合条件的查询，但条件是索引失效
	例如：select * from user where user_id='1'; user_id设置为varchar
		  select * from user where user_id=1; 这样也是可以查出来的，底层进行了类型转换
 查询优化	
		1.explain
	------------
		分析
		开启慢查询日志，设置阈值，将数据拿出来
		explain+慢sql分析
		show profile 查询服务器中sql执行细节和生命周期情况
		sql数据库服务器参数调优
		
		优化原则：小表驱动大表，即小的数据驱动大的数据集
		select * from a where id in (select id from B)
		当b表的数据集必须小于a表的数据集时，用in优于exsits
		select * from A where exsits (select i from N where B.id=A.id)
		当A表的数据集小于B表的数据集时，用exists优于in
	注意：A表和B表的ID字段应建立索引
	
	exists
		将查询的数据，放到子查询查询数据，根据
	单路，先对order by 排序
	order by 子句，尽量使用index方式排序，便面使用filesort方式排序
	尽可能在索引列上完成排序操作，遵守索引建的最佳左前缀
	如果不在索引列上，filesort有两种算法
		mysql 就要启动双路排序和单路排序	
	优化策略：
		增大sort_buffer_size参数
	
order by 
	双路排序
	单路排序
	
	1.order by 不要用*
	2.增加sort_buffer_size
	3.增大max_length_for_sorted_Data参数的设置
	

	10秒中以后的都是慢查询
---------------------------------------------------
mysql 排序方式：文件排序或扫描索引排序
mysql 能为排序与查询使用相同的索引
---------------------------------------------------
group by
where 高于having能写在where限定的条件就不要去having限定
------------------------------------
慢查询
long_query_time 默认大于10秒的执行sql时间
show variables like '%slow_query_log%' 
查询所有慢数据设置参数(开启，地址...)
set global slow_query_log=1 开启，（只有当前数据库关机关闭）

show variables like 'long_query_time%' 查看参数
set global long_query_time=3 修改参数（重新连接才能展示修改值）

show GLOBAL STATUS LIKE '%Slow_queries%'
查询慢查询的条数

mysqldumpslow 日志慢查询

函数有返回值，存储过程没有返回值

------------------------------------
批量数据脚本

delimiter $$
create function range(n int) return varchar(255)
begin
return 
end $$
delimiter $$ 定义结束符
------------------------------------
show profile
默认情况下处于关闭状态，并保存最近的12次运行结果

set profiling=on开启查看日志

show PROFILES
展示操作日志
show PROFILE cpu,block io for QUERY 1
展示
converting HEAP to myisam 查询结果太大，内存不够搬入磁盘
creating tmp table 创建临时表
copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！
Locked
------------------------------------
全局查询日志
	永远不要在生产环境开启这个功能
set global general_log=1;
开启
set global log_output='TABLE'
记录到 general_log表
select * from mysql.general_log
------------------------------------
锁
表锁(myisam偏多)：
	读锁（共享锁）：当前用户仅能读当前表，不能修改，不能读其他表；其他用户修改阻塞等待性能降低，读自由。

	写锁（排他锁）：当前写操作没有完成前，其他都不能操作，当前可以增改查
	
	简而言之，就是读锁会阻塞写，但是不会阻塞读，而写锁则会把读和写都堵塞。
	
	show open tables 哪些锁被加锁了 1为加锁
	lock table mylock read; 给mylock加读锁
	unlock tables; 解锁
	update mylock set name='a2' where id=1
	lock table mylock write; 写锁
	
	SHOW status like 'table%';
-------------------------------------------
行锁（偏向innodb）：
事务asid:原子性，一致性，隔离性，持久性

更新丢失：
脏读：读到已修改尚未提交的数据
不可重复读：事务a读取到事务b已经提交的修改数据，不符合隔离性
幻读：读到新增数据

未提交读
已提交读
可重复读
可序列化读

set autocommit=0;

CAS compare and swap 线程加版号


CAP
一致性(consistency)
可用性(availability)
分区容错性(partition tolerance)

行锁，大路朝天，各走一边，只会在一行进行操作

行锁变表锁
	索引失效导致行锁变表锁
	for update 排他锁
	
---------------------------------
间隙锁
	当我们用范围条件而不是相等条件检索数据，并请求共享 或排他锁时，innodb会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙GAP”
	
	innodb也会对这个“间隙”加索，这种锁机制就是所谓的间隙表(next-key锁)
	某些情况会对效率产生严重损害
-----------------------------------
for update (将所有查询到的数据加上排它锁)
	
	show status like 'innodb_row_lock%'; 展示行锁参数
	
优化建议：
	1.尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
	2.合理设计索引，尽量缩小锁的范围
	
	3.尽可能较少检索条件，避免间隙锁
	
	4.尽量控制事务大小，减少锁定资源量和时间长度
	
	5.尽可能低级别事务隔离
	
---------------------------------
页锁
-------------------------------
主从复制
	条件：
	1.mysql版本一致且后台以服务运行，同一网段
	2.主机：my.ini
		1.主服务器id唯一 server-id
		2.日志启动二进制文件
		3.启动错误日志
		4.根目录
		5.临时目录
		6.数据目录
		8.设置不要复制的数据库
		9.设置需要复制的数据库
	3.从机 my.cnf
		1.从服务器唯一 server-id
		2.启动二进制日志
		3.配置为重启服务器
		4.关闭防火墙
		5.windows授权从机slave权限 flush privileges
		show masetr status 展示主服务器状态
		6.配置从机读取主机数据同步配置
		7.start slave
		8.show slave status
		stop slave停止从机
-----------------------------------
myisam 索引记录的是数据地址，一定程度上可以直接拿去数据

innodb 索引记录的是主键，需要回表查询
支持事务，采用行级锁

缓存穿透：都没有数据






	
	
	


