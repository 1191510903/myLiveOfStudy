消息中间件
和dubbo等RPC的区别
1.一个同步一个异步
2.一个注重及时通信一个注重缓存
3.

MQ:消息中间件
activemq

1.在何种场景下使用消息中间件
2.为什么引用消息中间件

作用：
解耦，削峰，异步


高可用,高性能，可伸缩，易用和安全
异步消费和处理
控制消息的消费顺序
整合框架
集合配置

activeMQ默认端口是61616 提供JMS服务
ps -ef|grep activemq | grep -v grep  简化信息

ip:8161/admin/  8161提供管理控制台
admin
admin 默认账号密码

点对点的消息传递域中，目的地被称为队列queue
在发布订阅消息域中，目的地被称为主题topic

tcp://ip:端口

1.创建连接工厂
2.连接connection，并启动访问
3.创建会话session
4.创建目的地topic/queue
5.创建消息的生产者 MessageProducer producer=session.createProducer(queue)
6.通过messageProducer生成消息发送dao MQ的队列里面
7.TextMessage t =session.createTextMessage("sss");
8.发送消息producer.send(t);
9.关闭资源

消费者
同步阻塞方式
MessageConsumer consumer = session.createConsumer(queue)
TextMessage message = (TextMessage)consumer.receive(); 一直等待
receive(Long time); 时间限制

通过监听的方式来接受消息
consumer.setMessageListener(new MessageListener(){
	public void onMessage(Message message){
		
	}
})
System.in.read();保持控制台不灭

消费者三种情况
1.先生产 启动消费者
2.先生成 启动1号消费者，启动2号消费者不能接受消息
3.先启动两个消费者，再启动一个生产者
	结果：平均aa分配
JMS开发的基本步骤

topic
先启动消费者后启动生产者

===================================
javaEE :13个规范工业规范
JMS：两个应用程序之间进行异步通信的API

JMS prodiver 中间件
JMS producer 生产者
JMS consumer 消费者
JMS message 消息
	消息头
		1.JMSDestination 目的地
		2.JMSDeliveryMode 	持久非持久
		3.JMSExpiration 过期时间
		默认永不过期
		4.JMSPriority 优先级
		0-9 0-4普通 5-9加急
		默认是4
		5.JMSMessageID 唯一识别号
	消息属性
		去重/识别/重点标注
	消息体
		1.TextMessage
		2.MapMessage key-string value
		3.ByteMessage
		4.StreamMessage
		5.ObjectMessage

消息的可靠性
	1.持久:queue默认是持久（可靠性为主）
	topic 持久话订阅	一定要先运行一次消费者，进行注册clientID
	2.事务 
		ACID:原子、一致、隔离、持久
		事务：
		1.生产者send commit之前不会再进行发布
		失败rollback	2.消费者开启，commit之前会重复消费
	3.签收（偏消费者）
		自动签收 auto_ACKNOWLEDGE
		手动签收 CLIENT_ACKNOWLEDGE
		允许重复签收
		acknowledge
		
		事务提交后自动签收
		签收之后未提交依旧重复读
		
		事务优先级》签收优先级
	4.broker
		嵌入式broker,mq的实例
		BrokerServer broker = new BrokerServer();
		broker.setUseJmx(true)	broker.addConnect(localhost:61616)
		broker.start();
===================================
spring整合ActiveMQ
	 
pub-sub-main false:queue true:topic

springboot整合ActiveMQ
===================================
ActiveMQ传输协议
	主要协议：
		1.TCP:默认使用
		通过wire protocol（openWire）的序列化成字节流,促进网络效率和数据快速交互
		2.NIO:侧重底层访问
		3.AMQP
		4.stomp
		5.ssl
		6.MQTT
		7.ws
NIO:61618


加强NIO:auto:61608

===================================
消息持久化理论
	JDBC/LevelDB/KahaDB(默认-日志文件)
	
	kahaDB:
		消息存储使用一个事务日志和仅仅用一个索引B树文件进行存储
		db-1.log 存储日志文件
		db.data  索引文件
		db.free  显示空页id
		db.redo 日志恢复
		lock  锁
		
	JDBC:
		MQ+MQSQL
			1.添加mysql.jar  lib包
			2.xml  createTablesOnStartup 自动建表
			3.bean
		ACTIVEMQ_MSGS 消息（topic订阅的不删除）
		ACTIVEMQ_ACKS 队列的名字
		ACTIVEMQ_LOCK 集群主从
	
	jdbc-journal  加入缓存
=================================
	高可用：
		1.高可用集群(very fast)	zookeeper+replicated-levelDB-store
		2.jetty.xml
		
		
	losf -i 端口号
	grep -v grep
================================	1.如何保证其高可用：zookeeper+replicated-levelDB-store
2.什么是异步投递
	useAsyncSend=true
3.如何确定异步投递发送成功？
	接收回执
4.什么是延迟投递和定时投递？
	四大属性：
		延迟投递时间
		重复投递时间
		重复投递次数
		Cron表达式
	消息属性设置 setLongProperty
				 setIntProperty
5.重发机制
	1.rollback
	2.commit之前，没有commit
	3.在CLIENT_ACKNOWLEDGE的传递模式下，在session中调用了recover()
	
		间隔：1
		次数：6
		有毒消息Poison ACK
		超过6次定义有毒，broker把消息放到DLQ（死信队列）
6.死信队列
	处理失败消息的集合
		配置案例：
			自动删除过期消息
			存放非持久信息到死队列中
7.如何保证信息重复消费？幂等
			1.插入操作，设置主键
			2.第三方服务去存储 例如：redis key-value存储信息
			3.锁
			
	
			









