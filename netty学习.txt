netty学习
是一个异步的、基于事件驱动的网络应用框架
用以快速开发高性能、高可靠的网络IO程序

1.基于TCP/IP
2.本质是一个NIO框架

I/O模型：通过什么样的通道进行数据的发送和接收
	BIO：原生IO，同步并阻塞（传统阻塞性、型）
	NIO:同步非阻塞-多路复用
		selector(选择器)
	AIO:异步非阻塞
		异步通道
	BIO：适应连接数比较小且固定的架构
		连接池
	
	NIO：连接数目多且连接比较短
		
	
	AIO：连接数目多且连接比较长

java nio(new io)  同步非阻塞

channel  通道
buffer  缓存区
selector 选择器

BIO以流放肆处理数据，NIO以块的方式处理数据
块的效率更高
BUFFER是双向的

每一channel对应一个Buffer
================================== 
零拷贝AIO：从操作系统角度看，没有重复数据  transferTo
sendFile：使用socketBuffer-使用cpu
mmap优化：适合小数据量读写 用户映射
DMA:直接内存拷贝不使用CPU-传统io拷贝-不使用cpu

原生NIO存在的问题
1.API太难
2.工作量难道大
3.空轮询  -原生存在问题

netty:
	1.设计优雅
	2.使用方便
	3.高性能、吞吐量高、延迟更低
	4.安全
	5.社区活跃
netty 线程模型基本介绍
1)不同的线程模式
2)目前存在的线程模型：
	传统阻塞i/o服务模型
	reactor模型
解决传统阻塞i/o服务模型的2个缺点，解决方案：
1.i/o复用
2.线程池
说明:
	1)reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）
	2）服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此reactor模式也叫dispatcher模式
	
	3）reactor模型 使用io复用监听事件，收到事件后，分发给某个线程，这点就是网络服务高并发的处理关键


reactor模型
	1.reactor在一个单独的线程中运行
	2.eventHandler：处理程序执行i/o实际处理的事件

reactor 单线程模型
reactor 多线程模型
reactor 主从reactor多线程

1）netty抽象出两组线程池
	bossGroup 客户端连接
	workerGroup 专门负责网络的读写
2）NioEventLoopGroup 事件循环组  		
3）NioEventLoopGroup  表示一个不断循环的执行处理任务的线程
存在多个NioEventLoop
==========================
传统阻塞i/o 服务模型
==================
异步模型
异步的概念和同步相对
future
1）表示异步的执行结果，可以通过它提供的方法监测执行是否完成
2) ChannelFuture是一个接口
	当监听的事件发生时，就会通知到监听器
链式操作系统
	读取数据-数据处理（编码)-数据传输-数据处理（解码）
future-listener 机制
====================================
netty 核心组件

Bootstrap 引导
group 设置服务组
channel 设置服务端的通道
childOption  通道添加配置
childHandler 对应的workerGroup

Channel() 拿到当前io操作的通道

selector 

pipeline:
addFirst
addLast 把业务放进管道中
	
ChannelHandlerContext
NioEventLoopGroup 	
Unpooled  用来操作缓冲区容器
ByteBuf
	readIndex  读索引
	writeIndex  写索引
	capacity  数组长度
创建byteBuf
ByteBuf buffer = Unpooled.copiedBuffer;


心跳检测机制
  // IdleStateHandler 是netty 提供的处理空闲状态的处理器
  
 netty 通过websocket编程实现服务器和客户端长连接
 
 编码和解码的基本介绍
 1.数据传输为二进制，发送数据要编码，接收数据要解码
 2.netty使用java序列化进行编解码
 3.Geogle ProtoBuf -谷歌开源项目 适合RPC   
http+json ->tcp+protoBuf

childHandler进行数据入栈/出栈链的容器
TCP 粘包拆包
	
handler
client:编码：接收-代码-编码-发送
server:解码: 解码-代码-读取-发送




	
	
	
	