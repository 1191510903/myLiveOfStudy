SpringBoot特殊注解

@SpringbootAplication:	
	@Configuration	配置在类上，表示这个类是一个srping配置类，一般在这里面定义Bean,会把这个类中的bean加载到spring容器中

	@EnableAutoConfiguration	会在开启功能时自动配置，根据依赖的jar配置spring

	@ComponentScan	默认扫描所在包中的类，将bean转载到spring的bean容器中
	
	内存溢出：现有数据进入内存，内存不够使用。
		提高内存容量
	内存泄漏：对象引用不能被gc垃圾回收，导致现有数据内存不够。
	分类：常发性内存泄漏：多次执行到都会产生
	偶发性内存泄漏：特定情况下产生
	一次性内存泄漏：只会执行一次，例如构造方法
	隐式内存泄漏：程序运行时不停分配内存，直到结束释放内存。严格来说并没有发生内存泄漏。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致耗尽系统的所有内存。
	
	内存溢出的原因：
		1.内存中加载的数据量过于庞大
		2.集合类中有对象的引用
		3.存在死循环或循环产生过多的对象实体
		4.使用第三方软件中的Bug
		5.启动参数内存值设定的过小
		
	解决方案：
		1.修改jvm启动参数，直接增加内存
		2.检查错误日志，查看outofmemory 错误前是否有其他异常或错误
		3.对代码进行走查和分析

检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

检查代码中是否有死循环或递归调用。

检查是否有大循环重复产生新对象实体。

检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

第四步，使用内存查看工具动态查看内存使用情况


lock synchronized volatitle concurrentHashMap(synchronized CAS 数组+链表+红黑树) 

LOCK:排他锁与synchronized比可以动态代码实现等待停止锁。
readWriteLock：共享锁
=========================================
父pom
<dependencyManagement>
</dependencyManagement>

在所有在子项目中引用一个依赖而不用显式列出版本号,统一项目版本号

子项目写了依赖才继承jar，子项目没有版本才按照父项目依赖


<dependecies>
</dependecies>



	







	
	